# this script generates the qps/qgisenums.py
# qgisenums.py tries to provide unified access to enumerations
# across different QGIS API versions
import pathlib
import re
import urllib.request
from pathlib import Path
from typing import List

import qgis._3d
import qgis.analysis
import qgis.core
from qgis.core import Qgis

url = r'https://raw.githubusercontent.com/qgis/QGIS/master/src/core/qgis.h'
path_qgisenums = pathlib.Path(__file__).parents[1] / 'qps' / 'qgisenums.py'

NAMESPACE_CLASSES = {
    'qgis.core': vars(qgis.core),
    'qgis.gui': vars(qgis.gui),
    'qgis._3d': vars(qgis._3d),
    'qgis.analysis': vars(qgis.analysis)
}

NEW_NAME_VERSION_CORRECTION = {
    'PictureFormat': 34000,
    'ScaleBarAlignment': 34000,
    'ScaleBarDistanceLabelHorizontalPlacement': 34000,
    'ScaleBarDistanceLabelVerticalPlacement': 34000,
    'ScaleBarSegmentSizeMode': 34000,
    'VectorProviderCapability': 34000,
}

OLD_NAME_CORRECTION = {
    'QgsWkbTypes.GeometryType': 'QgsWkbTypes',
}

NEW_NAME_CORRECTION = {
    'DataProviderReadFlag': 'DataProviderFlag'
}

try:
    with urllib.request.urlopen(url) as response:
        code = response.read().decode('utf-8')
except urllib.error.URLError as e:
    print(f"Failed to download qgis.h: {e}")

code = re.sub('\n', ' ', code)
pattern = '/[*][^/]*Prior to.[^/]*/[ ]+enum[^:]*:'

rxSince = re.compile(r'\\since QGIS 3\.(\d+)')
rxPrior = re.compile(r'Prior to.*3\.(\d+) this was available as (Qgs[^ ]+)')
rxClass = re.compile(r'enum class ([^ ]+)')


class API_BREAK(object):

    def __init__(self, version_int: int, oldname: str, newname: str):
        self.version_int = version_int
        self.varname = f'QGIS_{newname.upper()}'
        self.oldname = oldname
        self.newname = newname


API_BREAKS: List[API_BREAK] = list()

for m in re.findall(pattern, code):

    matchSince = rxSince.search(m)
    matchPrior = rxPrior.search(m)
    matchClass = rxClass.search(m)

    nameNew = matchClass.group(1)
    nameOld = matchPrior.group(2)

    version_int = 30000
    # - 100 to include the developer versions on the master branch as well
    version_int += int(100 * float(matchPrior.group(1))) - 100

    if nameOld.endswith('.'):
        nameOld = nameOld[0:-1]
    nameOld = nameOld.replace('::', '.')
    API_BREAKS.append(API_BREAK(version_int=version_int,
                                oldname=nameOld,
                                newname=nameNew,
                                ))

lines = [f"""
# This autogenerated file provides unified access to enums which
# were removed between different QGIS API version.
# Do not modify, change {Path(__file__).name} instead!

from qgis.PyQt.QtCore import QVariant, QMetaType
from qgis.core import Qgis
"""]

manual_defined = """
# QgsField - since QGIS 3.38, use the method with a QMetaType::Type argument instead
QMETATYPE_QSTRING = QMetaType.Type.QString if Qgis.versionInt() >= 33800 else QVariant.String
QMETATYPE_QCHAR = QMetaType.Type.QChar if Qgis.versionInt() >= 33800 else QVariant.Char
QMETATYPE_QSTRINGLIST = QMetaType.Type.QStringList if Qgis.versionInt() >= 33800 else QVariant.StringList
QMETATYPE_BOOL = QMetaType.Type.Bool if Qgis.versionInt() >= 33800 else QVariant.Bool
QMETATYPE_INT = QMetaType.Type.Int if Qgis.versionInt() >= 33800 else QVariant.Int
QMETATYPE_DOUBLE = QMetaType.Type.Double if Qgis.versionInt() >= 33800 else QVariant.Double
QMETATYPE_UINT = QMetaType.Type.UInt if Qgis.versionInt() >= 33800 else QVariant.UInt
QMETATYPE_ULONG = QMetaType.Type.ULong
QMETATYPE_ULONGLONG = QMetaType.Type.ULongLong if Qgis.versionInt() >= 33800 else QVariant.ULongLong
QMETATYPE_LONGLONG = QMetaType.Type.LongLong if Qgis.versionInt() >= 33800 else QVariant.LongLong
QMETATYPE_QTIME = QMetaType.Type.QTime if Qgis.versionInt() >= 33800 else QVariant.Time
QMETATYPE_QDATE = QMetaType.Type.QDate if Qgis.versionInt() >= 33800 else QVariant.Date
QMETATYPE_QDATETIME = QMetaType.Type.QDateTime if Qgis.versionInt() >= 33800 else QVariant.DateTime
QMETATYPE_QVARIANTMAP = QMetaType.Type.QVariantMap if Qgis.versionInt() >= 33800 else QVariant.Map
QMETATYPE_QBYTEARRAY = QMetaType.Type.QByteArray if Qgis.versionInt() >= 33800 else QVariant.ByteArray
QMETATYPE_QVARIANTLIST = QMetaType.Type.QVariantList if Qgis.versionInt() >= 33800 else QVariant.List
"""

# init all

API_BREAKS = sorted(API_BREAKS, key=lambda b: b.newname)

switchlines = []
required_imports = set()

for b in API_BREAKS:
    required_imports.add(b.oldname.split(".")[0])
    switchline = (f'{b.varname} = Qgis.{NEW_NAME_CORRECTION.get(b.newname, b.newname)} '
                  f'if Qgis.versionInt() >= {NEW_NAME_VERSION_CORRECTION.get(b.newname, b.version_int)} '
                  f'else {OLD_NAME_CORRECTION.get(b.oldname, b.oldname)}')
    switchlines.append(switchline)

required_imports = sorted(required_imports)

NAMESPACES = {'qgis.core',
              'qgis.gui',
              }

CHANGES = {}

for i in required_imports:
    for ns, ns_classes in NAMESPACE_CLASSES.items():
        if i in ns_classes:
            CHANGES[ns] = CHANGES.get(ns, []) + [i]

lines.append('\n#  Import old locations')
for ns, ns_classes in CHANGES.items():
    lines.append(f'from {ns} import (' + ', '.join(ns_classes) + ')')

lines.append('\n#  API Switches')
lines.append(manual_defined)
lines.append('')
lines.extend(switchlines)
lines.append('')  # final newline

print(f'Write {path_qgisenums}...')
with open(path_qgisenums, 'w', encoding='utf8') as f:
    f.write('\n'.join(lines))

print(f'Test import {path_qgisenums.name} in {Qgis.versionInt()}')
qps_enums = __import__('qps.qgisenums')

all_names = dir(qps_enums)
for n in all_names:
    if not n.startswith('_'):
        print(f'{n} = {getattr(qps_enums, n)}')

print('Done!')
